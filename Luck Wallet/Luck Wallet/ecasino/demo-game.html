<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LuckyTime Color Game</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <style>
    /* reset & box‚Äêsizing */
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
  margin: 0;
  padding: 0;
  font-family: 'Cinzel', serif;
  background: linear-gradient(135deg, #0f2027, #203a43, #2c5364); /* example */
  background-size: 400% 400%;
  animation: gradientMove 15s ease infinite;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
    }
    @keyframes gradientMove {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
    }

    h1 {
      color: #ffdd57;
      margin-bottom: 20px;
      text-shadow: 0 0 8px rgba(255,221,87,0.7);
      font-size: 2rem;
      letter-spacing: 1px;
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1001;
    }


    .left-panel, .right-panel {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        padding: 0 10px;
        max-width: 50%;
        height: calc(100vh - 40px);
        justify-content: center;
    }

    .board-container {
      width: 480px;
      height: 270px;
      perspective: 1200px;
      margin-bottom: 30px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .board {
  width: 460px;
  height: 600px;
  background: #0a2240;
  border: 10px solid #ffdd57;
  border-radius: 16px;
  transform: rotateX(35deg); /* Changed from 65deg to 35deg */
  box-shadow:
    inset 0 0 30px rgba(0,0,0,0.8),
    0 10px 30px rgba(0,0,0,0.6);
  position: relative;
  overflow: hidden;
}


    .cube {
      position: absolute;
      width: 64px;
      height: 64px;
      transform-style: preserve-3d;
      transition: transform 1s ease, top 1s ease, left 1s ease;
    }

    .cube .face {
      position: absolute;
      width: 64px;
      height: 64px;
      border: 2px solid #111;
      backface-visibility: hidden;
    }

    .front  { transform: translateZ(32px); }
    .back   { transform: rotateY(180deg) translateZ(32px); }
    .right  { transform: rotateY( 90deg) translateZ(32px); }
    .left   { transform: rotateY(-90deg) translateZ(32px); }
    .top    { transform: rotateX( 90deg) translateZ(32px); }
    .bottom { transform: rotateX(-90deg) translateZ(32px); }

    .controls {
      width: 90%;
      max-width: 2000px;
      background: rgba(0,0,0,0.4);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
      text-align: center;
      margin-bottom: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      flex-wrap: nowrap;
      gap: 20px;
      margin-top: 100px;
    }

    #rollBtn {
      padding: 14px 32px;
      background: linear-gradient(145deg, #3b8dff, #005ecb);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      text-shadow: 0 0 4px rgba(0,0,0,0.5);
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    #rollBtn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 14px rgba(0,0,0,0.7);
    }

    .color-row {
      display: flex;
      justify-content: center;
      gap: 14px;
    }

    .color-box {
      width: 50px;
      height: 50px;
      border: 3px solid #333;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s;
    }
    .color-box:hover {
      transform: scale(1.1);
    }
    .selected {
      border-color: #ffdd57;
      box-shadow: 0 0 8px rgba(255,221,87,0.8);
    }

    .bet {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      font-size: 1.1rem;
    }
    .bet label {
      font-weight: bold;
      color: white;
    }
    #betAmount {
      width: 100px;
      padding: 8px;
      font-size: 1rem;
      border-radius: 6px;
      border: none;
      text-align: center;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal-content {
      background: #1f2833;
      color: #c5c6c7;
      padding: 24px;
      border-radius: 12px;
      width: 90%; max-width: 400px;
      text-align: left;
      box-shadow: 0 0 30px rgba(0,0,0,0.8);
      position: relative;
    }
    .modal-content h2 {
      color: #66fcf1;
      margin-bottom: 16px;
      text-align: center;
    }
    .modal-content ul {
      margin: 12px 0;
      padding-left: 20px;
    }
    .modal-content p {
      margin-top: 12px;
    }
    .modal-content .close {
      position: absolute;
      top: 12px; right: 12px;
      font-size: 24px;
      color: #c5c6c7;
      cursor: pointer;
    }
    /* Styles for the new insufficient funds modal */
    .modal-content.insufficient-funds {
        background: #331f1f; /* Darker red background */
        border: 2px solid #ff4d4d; /* Red border */
    }
    .modal-content.insufficient-funds h2 {
        color: #ff4d4d; /* Red heading */
    }
    .modal-content.insufficient-funds p {
        text-align: center;
        font-size: 1.1rem;
        margin-top: 15px;
        color: #f0f0f0;
    }
    .modal-content.insufficient-funds .icon {
        font-size: 3rem;
        color: #ff4d4d;
        text-align: center;
        margin-bottom: 10px;
    }


    @media (max-width: 768px) {
      body {
        flex-direction: column;
        padding: 10px;
      }

      .left-panel, .right-panel {
        max-width: 100%;
        height: auto;
        padding: 10px 0;
      }

      .controls {
        flex-direction: column;
        margin-bottom: 15px;
        gap: 10px;
      }
      .controls #rollBtn, .controls .color-row, .controls .bet {
        margin-bottom: 0;
      }
    }
  </style>
</head>
<body>


  <div class="left-panel">
    <div class="controls">
      <button id="rollBtn">ROLL DICE</button>

      <div class="color-row" id="colorRow"></div>

      <div class="bet">
        <label for="betAmount">Bet:</label>
        <input type="number" id="betAmount" min="1" value="10" />
      </div>
    </div>
  </div>

  <div class="right-panel">
    <div class="board-container">
      <div class="board" id="board"></div>
    </div>
  </div>

  <div id="resultModal" class="modal">
    <div class="modal-content">
      <span class="close" id="modalClose">&times;</span>
      <h2>üé≤ Roll Results</h2>
      <p><strong>Bet:</strong> <span id="modalBet"></span></p>
      <p><strong>Color:</strong> <span id="modalColor"></span></p>
      <ul id="modalResults"></ul>
      <p><strong id="modalOutcome"></strong></p>
    </div>
  </div>

  <div id="insufficientFundsModal" class="modal">
    <div class="modal-content insufficient-funds">
      <span class="close" id="insufficientFundsClose">&times;</span>
      <div class="icon"><i class="fas fa-exclamation-circle"></i></div>
      <h2>Insufficient Funds!</h2>
      <p>Your balance is too low to place this bet.</p>
      <p>Please add more funds to continue playing.</p>
    </div>
  </div>

  <script>
    const colors = ['yellow', 'white', 'magenta', 'blue', 'red', 'green'];
    const board = document.getElementById('board');
    const rollBtn = document.getElementById('rollBtn');
    const colorRow = document.getElementById('colorRow');
    const betInput = document.getElementById('betAmount');
    const modal = document.getElementById('resultModal'); // Main result modal
    const modalClose = document.getElementById('modalClose');
    const modalResults = document.getElementById('modalResults');
    const modalOutcome = document.getElementById('modalOutcome');
    const modalBet = document.getElementById('modalBet');
    const modalColor = document.getElementById('modalColor');

    // New modal elements
    const insufficientFundsModal = document.getElementById('insufficientFundsModal');
    const insufficientFundsClose = document.getElementById('insufficientFundsClose');


    let selectedColor = colors[0]; // Initialize with a default selected color, e.g., 'yellow'


    // Event listener for color selection
    colors.forEach(color => {
      const box = document.createElement('div');
      box.className = 'color-box';
      box.style.background = color;
      box.setAttribute('data-color', color); // Add data-color attribute for easy retrieval
      box.addEventListener('click', () => {
        document.querySelectorAll('.color-box').forEach(b => b.classList.remove('selected'));
        box.classList.add('selected');
        selectedColor = color;
      });
      colorRow.appendChild(box);
      if (color === selectedColor) box.classList.add('selected'); // Set initial selected
    });

    // Helper function for shuffling
    function shuffle(array) {
      return [...array].sort(() => Math.random() - 0.5);
    }

    // Function to create a single cube
    // Now accepts an optional fixedTopColor to ensure visual consistency with server outcome
    function createCube(index, fixedTopColor = null) {
      const cube = document.createElement('div');
      cube.className = 'cube';
      let faceColors = shuffle(colors);

      // If a fixed top color is provided, ensure it's the 5th element (index 4, which is the 'top' face)
      if (fixedTopColor && colors.includes(fixedTopColor)) {
          // Remove the fixed color from the shuffled array if it's already there
          faceColors = faceColors.filter(color => color !== fixedTopColor);
          // Insert it at the 'top' face position (index 4)
          faceColors.splice(4, 0, fixedTopColor);
      }

      const faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];

      faces.forEach((face, i) => {
        const faceDiv = document.createElement('div');
        faceDiv.className = `face ${face}`;
        faceDiv.style.background = faceColors[i];
        cube.appendChild(faceDiv);
      });

      cube.style.top = '-70px';
      cube.style.left = `${board.offsetWidth / 2 - 32 + (index - 1) * 90 + (Math.random() - 0.5) * 20}px`;
      board.appendChild(cube);

      return { cube, faceColors };
    }

    // --- Core game logic and server communication ---
    async function rollCubes() {
      console.log("rollCubes function started.");
      // Disable UI elements to prevent multiple submissions
      rollBtn.disabled = true;
      betInput.disabled = true; // Disable bet input
      document.querySelectorAll('.color-box').forEach(box => box.style.pointerEvents = 'none'); // Disable color selection

      // Hide any currently open modals
      modal.style.display = 'none';
      insufficientFundsModal.style.display = 'none';

      // Clear previous results and prepare modal
      board.innerHTML = '';
      modalResults.innerHTML = '';
      modalOutcome.textContent = 'Processing bet...'; // Immediate feedback

      const bet = parseFloat(betInput.value); // Use parseFloat for bet amount
      const chosenColor = selectedColor; // Get the currently selected color

      console.log("Bet amount:", bet);
      console.log("Chosen color:", chosenColor);

      // Basic client-side validation before sending to server
      if (isNaN(bet) || bet <= 0) {
        alert("Please enter a valid bet amount.");
        console.error("Validation failed: Invalid bet amount.");
        rollBtn.disabled = false;
        betInput.disabled = false; // Re-enable
        document.querySelectorAll('.color-box').forEach(box => box.style.pointerEvents = 'auto'); // Re-enable
        return; // Don't show any modal, just alert
      }
      if (!chosenColor) {
        alert("Please choose a color.");
        console.error("Validation failed: No color chosen.");
        rollBtn.disabled = false;
        betInput.disabled = false; // Re-enable
        document.querySelectorAll('.color-box').forEach(box => box.style.pointerEvents = 'auto'); // Re-enable
        return; // Don't show any modal, just alert
      }

      console.log("Client-side validation passed. Attempting to fetch...");

      try {
        // Send data to the server (update_balance.php)
        const response = await fetch('update_balance.php', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            game: 'color_game', // Identifies which game logic to use on the server
            bet: bet,
            chosenColor: chosenColor // The client's chosen color
          }),
        });
        console.log("Fetch request sent. Awaiting response...");

        const data = await response.json();
        console.log("Response received:", data);

        // --- Handle Insufficient Funds specifically ---
        if (!data.success && data.message === 'Insufficient funds.') {
            insufficientFundsModal.style.display = 'flex'; // Show custom insufficient funds modal
            // No dice animation needed for insufficient funds
        } else if (data.success) {
            // --- Animate cubes using server-determined results ---
            // Get the server's dice results for animation
            const serverDiceResults = data.serverDiceResults || []; // Use the new array from PHP

            for (let i = 0; i < 3; i++) {
                // Use the actual color from the server's results for the top face of each cube
                let cubeFixedColor = serverDiceResults[i] || colors[Math.floor(Math.random() * colors.length)]; // Fallback just in case

                const { cube, faceColors } = createCube(i, cubeFixedColor); // Pass fixedTopColor
                await new Promise(res => setTimeout(res, 200));

                // Position cubes to appear on the board
                const finalTop = board.offsetHeight / 2 - 32;
                const finalLeftOffset = (i - 1) * 100; // Positions them side-by-side
                const finalLeft = board.offsetWidth / 2 - 32 + finalLeftOffset;

                const finalTransform = 'rotateX(-90deg) rotateY(0deg) rotateZ(0deg)'; // Shows the 'top' face

                cube.style.top = `${finalTop}px`;
                cube.style.left = `${finalLeft}px`;
                cube.style.transform = finalTransform;
            }
            await new Promise(res => setTimeout(res, 1500)); // Wait for animation to finish


            // Update main result modal with results from the server
            modalBet.textContent = bet.toFixed(2); // Display bet amount with 2 decimal places
            modalColor.textContent = chosenColor.charAt(0).toUpperCase() + chosenColor.slice(1); // Capitalize chosen color

            // Display individual cube results using server's array
            modalResults.innerHTML = ''; // Clear previous content
            serverDiceResults.forEach((topColor, i) => {
                const li = document.createElement('li');
                li.textContent = `üé≤ Die ${i + 1}: Top color = ${topColor.charAt(0).toUpperCase() + topColor.slice(1)}`;
                modalResults.appendChild(li);
            });

            // Use the server's message directly for the outcome
            modalOutcome.textContent = data.message;
            modal.style.display = 'flex'; // Show main result modal

            // --- Crucial: Send new balance to the parent window (color-game.php) ---
            if (window.parent) { // Check if there's a parent window
                window.parent.postMessage({
                    type: 'GAME_OVER',
                    newBalance: data.newBalance // Send the balance received from the server
                }, '*'); // '*' for any origin, or specify your parent's exact URL for more security
            }

        } else {
            // General error (not insufficient funds), show in main result modal
            modalBet.textContent = bet.toFixed(2);
            modalColor.textContent = chosenColor.charAt(0).toUpperCase() + chosenColor.slice(1);
            modalResults.innerHTML = `<li>Error: ${data.message}</li>`;
            modalOutcome.textContent = 'Game Failed!';
            modal.style.display = 'flex'; // Show main result modal
        }

      } catch (error) {
        console.error('Error during game play (catch block):', error);
        modalBet.textContent = bet.toFixed(2);
        modalColor.textContent = chosenColor.charAt(0).toUpperCase() + chosenColor.slice(1);
        modalResults.innerHTML = `<li>A network error occurred or the server is unreachable.</li>`;
        modalOutcome.textContent = 'Connection Error!';
        modal.style.display = 'flex'; // Show main result modal for connection error
      } finally {
        console.log("rollCubes function finished (finally block).");
        // Re-enable UI elements regardless of which modal was shown or error
        rollBtn.disabled = false;
        betInput.disabled = false; // Re-enable
        document.querySelectorAll('.color-box').forEach(box => box.style.pointerEvents = 'auto'); // Re-enable
      }
    }

    // Event Listeners for both modals
    rollBtn.addEventListener('click', rollCubes);
    modalClose.addEventListener('click', () => modal.style.display = 'none');
    insufficientFundsClose.addEventListener('click', () => insufficientFundsModal.style.display = 'none'); // New close listener

    // Close modals on outside click
    window.addEventListener('click', (e) => {
      if (e.target === modal) modal.style.display = 'none';
      if (e.target === insufficientFundsModal) insufficientFundsModal.style.display = 'none'; // New outside click listener
    });

    // Initial cube positioning on load and resize
    function positionCubesInitially() {
        const existingCubes = document.querySelectorAll('.cube');
        existingCubes.forEach(cube => cube.remove());
        for (let i = 0; i < 3; i++) {
            createCube(i);
        }
    }
    window.onload = positionCubesInitially;
    window.onresize = positionCubesInitially;
  </script>
</body>
</html>