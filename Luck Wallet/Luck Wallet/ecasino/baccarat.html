<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LuckyTime Baccarat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet" />
    <style>
    :root {
      --dark-bg: #1a202c;
      --felt-green-dark: #02432a;
      --felt-green-light: #046a41;
      --felt-green: #0b3d02; /* Kept from hi-lo if used separately */
      --gold-accent: #d4af37;
      --red-accent: #e53e3e;
      --blue-accent: #4299e1;
      --text-light: #e2e8f0; /* Standardized to this */
      --border-color: #3b4251;
      --card-bg: #f5f5f5;
      --card-text-dark: #2d3748;
      --chip-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      --chip-red: #c0392b; /* From hi-lo */
      --chip-black: #2c3e50; /* From hi-lo */
      --modal-bg: rgba(0, 0, 0, 0.75);
      --shadow: 0 4px 8px rgba(0,0,0,0.7); /* General shadow */
    }

    html, body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        box-sizing: border-box;
    }

    body {
        margin: 0;
        padding: 0;
        font-family: 'Cinzel', serif;
        background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
        background-size: 400% 400%;
        animation: gradientMove 15s ease infinite;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
    }

    @keyframes gradientMove {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }

    .game-container {
        background-color: #2d3748;
        border-radius: 1.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        width: 100%;
        height: 100%;
        max-width: 1200px;
        max-height: 95vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        border: 2px solid #4a5568;
        box-sizing: border-box;
    }

    .game-header, .game-footer {
        flex-shrink: 0;
        background-color: #3b4251;
        padding: 1.5rem 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: var(--text-light);
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .game-header {
        border-bottom: 1px solid var(--border-color);
        border-top-left-radius: 1.5rem; /* Adjusted to match container */
        border-top-right-radius: 1.5rem; /* Adjusted to match container */
    }

    .game-footer {
        border-top: 1px solid var(--border-color);
        border-bottom-left-radius: 1.5rem; /* Adjusted to match container */
        border-bottom-right-radius: 1.5rem; /* Adjusted to match container */
        flex-wrap: wrap; /* Added for responsiveness of chips */
        justify-content: center; /* Center chips */
        gap: 0.5rem; /* Gap between chips */
    }

    .baccarat-table {
        background: linear-gradient(to bottom, #065f46, #047857);
        border-radius: 1.5rem;
        padding: 1.5rem;
        position: relative;
        flex-grow: 1;
        display: grid;
        grid-template-rows: 1fr 1.5fr 1fr; /* Mobile first: Player, Middle, Banker vertically */
        grid-template-columns: 1fr;
        gap: 1rem;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        border: 8px solid #5a3e2a;
        box-sizing: border-box;
        overflow: auto;
    }

    @media (min-width: 768px) { /* Tablet and larger: 3 columns */
        .baccarat-table {
            grid-template-rows: 1fr; /* Single row */
            grid-template-columns: 1fr 1.5fr 1fr; /* Player, Middle, Banker horizontally */
        }
    }

    .card-slot {
        background-color: rgba(0, 0, 0, 0.3);
        border: 1px dashed rgba(255, 255, 255, 0.3);
        border-radius: 0.5rem;
        min-height: 120px;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0.5rem;
        gap: 0.5rem;
        flex-wrap: wrap;
        height: 100%;
        box-sizing: border-box;
    }

    .card-container {
      width: 70px;
      height: 100px;
      background: white;
      border-radius: 8px;
      box-shadow: var(--shadow);
      position: relative;
      perspective: 1000px;
      flex-shrink: 0;
      opacity: 0;
      transition: opacity 0.2s ease-out;
    }

    .card-container.dealt {
        opacity: 1;
    }

    .card-inner { /* Not explicitly used in Baccarat's current card reveal but kept for potential future use */
        position: relative;
        width: 100%;
        height: 100%;
        text-align: center;
        transition: transform 0.6s;
        transform-style: preserve-3d;
    }

    .card-container.flipped .card-inner { /* For flip animation if implemented */
        transform: rotateY(180deg);
    }

    .card-front, .card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        border-radius: 8px;
        border: 1px solid #ccc;
        box-sizing: border-box;
    }

    .card-front {
        background-color: var(--card-bg);
        color: var(--card-text-dark);
        font-family: 'Playfair Display', serif;
        font-weight: 700;
        font-size: 1.1em;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: flex-start;
        padding: 0; /* Corner ranks are absolutely positioned */
    }

    .card-front .corner-rank {
        position: absolute;
        font-size: 1.2em; /* Consider adjusting if it overflows small cards */
    }

    .card-front .top-left {
        top: 2%;
        left: 5%;
    }

    .card-front .bottom-right {
        bottom: 2%;
        right: 5%;
        transform: rotate(180deg);
    }

    .card-front .suit-icon {
        position: absolute;
        font-size: 1em; /* Base size, consider scaling for central display */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

    .card-back {
        background: linear-gradient(45deg, #1A1A1A 25%, transparent 25%, transparent 75%, #1A1A1A 75%, #1A1A1A),
                    linear-gradient(135deg, #1A1A1A 25%, transparent 25%, transparent 75%, #1A1A1A 75%, #1A1A1A);
        background-size: 15px 15px;
        background-color: #550000;
        border: 1px solid #ccc;
        border-radius: 8px;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
    }

    .card-back::before { /* Can be used for a logo or symbol if needed */
        content: '';
    }

    .red-suit { color: #e53e3e; }
    .black-suit { color: #2d3748; }

    .chip {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        cursor: pointer;
        border: 3px solid rgba(255, 255, 255, 0.5);
        box-shadow: var(--chip-shadow);
        transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
        flex-shrink: 0;
    }

    .chip:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
    }

    .chip.selected {
        border-color: #fcd34d; /* gold-accent could be used here */
        transform: scale(1.1);
        box-shadow: 0 0 15px #fcd34d;
    }

    .bet-area {
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 0.75rem;
        padding: 0.5rem;
        min-width: 100px;
        text-align: center;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        position: relative;
        overflow: hidden; /* Important for placed-chip animation */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        flex-grow: 1;
        height: 100%; /* Ensure it fills space in grid/flex parent */
        box-sizing: border-box;
    }

    .bet-area:hover {
        background-color: rgba(0, 0, 0, 0.6);
        transform: translateY(-2px);
    }

    .bet-area.active { /* If you want to show active bet areas differently */
        border: 2px solid var(--gold-accent);
        box-shadow: 0 0 10px var(--gold-accent);
    }

    .placed-chip {
        position: absolute;
        bottom: 5px;
        left: 50%;
        transform: translateX(-50%);
        width: 40px; /* Slightly smaller than selectable chips */
        height: 40px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        color: white;
        background-color: #ef4444; /* Default, overridden by JS */
        border: 2px solid rgba(255, 255, 255, 0.7);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        animation: placeChip 0.3s ease-out forwards;
    }

    @keyframes placeChip {
        from { transform: translateX(-50%) translateY(-20px) scale(0.5); opacity: 0; }
        to { transform: translateX(-50%) translateY(0) scale(1); opacity: 1; }
    }

    .message-box {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--dark-bg); /* Using a theme variable */
        color: var(--text-light);
        padding: 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        z-index: 1000;
        text-align: center;
        display: none; /* Controlled by JS */
        max-width: 90%; /* For smaller screens */
    }

    .message-box button {
        background-color: #48bb78; /* Consider theme variable e.g. --felt-green-light */
        color: white;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        margin-top: 1rem;
        cursor: pointer;
        transition: background-color 0.2s;
        border: none;
    }

    .message-box button:hover {
        background-color: #38a169;
    }

    /* Responsive adjustments for cards */
    @media (max-width: 768px), (orientation: portrait) {
        .card-container {
            width: 8vmin; /* Using vmin for responsive card size */
            height: 11.2vmin; /* Maintain aspect ratio */
        }
        .card-front .corner-rank { font-size: 1.1em; } /* Relative to card size */
        .card-front .suit-icon { font-size: 3.5em; } /* Larger central suit */
        .card-back { font-size: 1.8em; } /* For any text/icon on back */
        .game-header, .game-footer {
            padding: 1rem 0.5rem; /* Less padding on smaller screens */
        }
    }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen p-4">
    <main class="game-container">
        <header class="game-header w-full bg-gray-800 p-4 rounded-t-2xl flex flex-col sm:flex-row justify-between items-center text-sm md:text-base">
            <h1 class="text-xl md:text-2xl font-bold text-center text-blue-300 mb-2 sm:mb-0">LuckyTime Baccarat</h1>
            <div class="flex items-center space-x-2 sm:space-x-4"> <span id="current-time" class="text-gray-400 text-xs sm:text-sm"></span>
                <div class="flex items-center space-x-1 sm:space-x-2">
                   
                </div>
                <div class="flex items-center space-x-1 sm:space-x-2">
                    <span class="text-gray-400 text-xs sm:text-sm">Balance: <span id="user-balance" class="text-yellow-300 font-semibold">Loading...</span></span>
                </div>
            </div>
        </header>

        <section class="baccarat-table">
            <div class="flex flex-col items-center justify-around">
                <h2 class="text-2xl md:text-3xl font-bold text-blue-400 mb-2 tracking-widest">PLAYER</h2>
                <div id="player-cards" class="card-slot w-full max-w-xs flex-grow"></div>
                <div id="player-score" class="text-3xl font-extrabold text-blue-200 mt-2">0</div>
            </div>

            <div class="flex flex-col items-center justify-around">
                <div class="flex flex-col items-center mb-4">
                    <p class="text-lg text-gray-300 mb-2">Total Bet: <span id="total-bet" class="font-semibold text-yellow-300">0</span></p>
                    <div class="flex space-x-2 mb-4 w-full justify-center">
                        <div id="player-bet-area" class="bet-area h-24 text-lg font-bold text-blue-200" data-bet-type="player">
                            PLAYER
                            <span id="player-bet-amount" class="text-sm text-yellow-300 mt-1">0</span>
                        </div>
                        <div id="tie-bet-area" class="bet-area h-24 text-lg font-bold text-green-200" data-bet-type="tie">
                            TIE <span class="text-xs sm:text-sm font-normal">(PAYS 8-1)</span>
                            <span id="tie-bet-amount" class="text-sm text-yellow-300 mt-1">0</span>
                        </div>
                        <div id="banker-bet-area" class="bet-area h-24 text-lg font-bold text-red-200" data-bet-type="banker">
                            BANKER
                            <span id="banker-bet-amount" class="text-sm text-yellow-300 mt-1">0</span>
                        </div>
                    </div>
                </div>

                <div id="game-message" class="text-xl font-bold text-yellow-300 mb-4 text-center h-10">Place your bets!</div>

                <div class="flex flex-wrap justify-center gap-2 sm:gap-4 mt-4">
                    <button id="deal-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full shadow-lg transition transform hover:scale-105 active:scale-95 text-sm sm:text-base">
                        <i class="fas fa-hand-sparkles mr-1 sm:mr-2"></i>DEAL
                    </button>
                    <button id="clear-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-full shadow-lg transition transform hover:scale-105 active:scale-95 text-sm sm:text-base">
                        <i class="fas fa-eraser mr-1 sm:mr-2"></i>CLEAR BETS
                    </button>
                    <button id="new-game-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full shadow-lg transition transform hover:scale-105 active:scale-95 text-sm sm:text-base">
                        <i class="fas fa-redo-alt mr-1 sm:mr-2"></i>NEW GAME
                    </button>
                </div>
            </div>

            <div class="flex flex-col items-center justify-around">
                <h2 class="text-2xl md:text-3xl font-bold text-red-400 mb-2 tracking-widest">BANKER</h2>
                <div id="banker-cards" class="card-slot w-full max-w-xs flex-grow"></div>
                <div id="banker-score" class="text-3xl font-extrabold text-red-200 mt-2">0</div>
            </div>
        </section>

        <footer class="game-footer w-full bg-gray-700 p-4 rounded-b-2xl">
            <span class="text-lg font-semibold mr-2 text-gray-200">Chips:</span>
            <div class="chip bg-red-500 text-white" data-value="1" aria-label="Chip value 1">1</div>
            <div class="chip bg-blue-500 text-white" data-value="5" aria-label="Chip value 5">5</div>
            <div class="chip bg-green-500 text-white" data-value="10" aria-label="Chip value 10">10</div>
            <div class="chip bg-yellow-500 text-white" data-value="25" aria-label="Chip value 25">25</div>
            <div class="chip bg-purple-500 text-white" data-value="50" aria-label="Chip value 50">50</div>
            <div class="chip bg-indigo-500 text-white" data-value="100" aria-label="Chip value 100">100</div>
        </footer>
    </main>

    <div id="message-box" class="message-box">
        <div id="message-text" class="text-lg"></div> <button id="message-ok-button">OK</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth;
        let userId = 'anonymous'; // Default userId

        // --- Elements ---
        const totalBetEl = document.getElementById('total-bet');
        const playerCardsEl = document.getElementById('player-cards');
        const playerScoreEl = document.getElementById('player-score');
        const bankerCardsEl = document.getElementById('banker-cards');
        const bankerScoreEl = document.getElementById('banker-score');
        const gameMessageEl = document.getElementById('game-message');
        const chipEls = document.querySelectorAll('.chip');
        const betAreaEls = document.querySelectorAll('.bet-area');
        const dealButton = document.getElementById('deal-button');
        const clearButton = document.getElementById('clear-button');
        const newGameButton = document.getElementById('new-game-button');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageOkButton = document.getElementById('message-ok-button');
        const userBalanceEl = document.getElementById('user-balance');
        const currentTimeEl = document.getElementById('current-time');

        // --- Game State & Logic Variables ---
        const SUITS = ['♠️', '♥️', '♦️', '♣️'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        let playerHand = [];
        let bankerHand = [];
        let bets = { player: 0, banker: 0, tie: 0 };
        let selectedChipValue = 1;
        let gameInProgress = false;
        let currentBalance = 0; // Variable to store user's balance

        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.value = this.getBaccaratValue();
                this.symbol = suit; // Suit symbol for display
            }

            getBaccaratValue() {
                if (['10', 'J', 'Q', 'K'].includes(this.rank)) return 0;
                if (this.rank === 'A') return 1;
                return parseInt(this.rank);
            }
        }

        class Deck {
            constructor(numDecks = 8) { // Standard is usually 6 or 8 decks
                this.numDecks = numDecks;
                this.cards = [];
                this.reset();
            }

            reset() {
                this.cards = [];
                for (let i = 0; i < this.numDecks; i++) {
                    for (const suit of SUITS) {
                        for (const rank of RANKS) {
                            this.cards.push(new Card(suit, rank));
                        }
                    }
                }
                this.shuffle();
            }

            shuffle() {
                for (let i = this.cards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
                }
            }

            dealCard() {
                if (this.cards.length < (this.numDecks * 52 * 0.25) ) { // Reshuffle if less than 25% cards left, for example
                    this.reset();
                    showMessage("Deck Reshuffled", "The shoe has been reshuffled with fresh cards.");
                }
                if (this.cards.length === 0) { // Fallback, should be caught by above
                    this.reset(); // Should not happen if above logic is correct
                     showMessage("Deck Empty", "Deck was empty and has been reshuffled.");
                }
                return this.cards.pop();
            }
        }

        const deck = new Deck();

        // --- Firebase Initialization ---
        const initFirebase = async () => {
            try {
                if (Object.keys(firebaseConfig).length > 0 && firebaseConfig.apiKey) { // Check for apiKey too
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    onAuthStateChanged(auth, (user) => {
                        if (user) {
                            userId = user.uid;
                            console.log("User signed in:", userId);
                        } else {
                            userId = 'anonymous';
                            console.log("User signed out or anonymous.");
                            // For anonymous sign-in if no token
                            if (!initialAuthToken && auth) { // Ensure auth is initialized
                                signInAnonymously(auth).catch((error) => {
                                    console.error("Anonymous sign-in failed:", error);
                                });
                            }
                        }
                        fetchAndUpdateBalance(true); // Fetch balance after auth state is resolved
                    });

                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else if (!auth.currentUser) { // If not already signed in by onAuthStateChanged or custom token
                        await signInAnonymously(auth);
                    }
                } else {
                    console.log("Firebase config not provided or incomplete. Running in offline/PHP session mode for balance.");
                    userId = 'php_session_user'; // Placeholder for non-Firebase auth user
                    fetchAndUpdateBalance(true); // Fetch balance for PHP session user
                }
            } catch (error) {
                console.error("Firebase initialization error:", error);
                userId = 'init_error_user'; // Indicate init error
                fetchAndUpdateBalance(true); // Still try to fetch balance, relying on PHP session
            }
        };

        // --- Balance Management ---
        async function fetchAndUpdateBalance(isInitialLoad = false) {
            try {
                const payload = { game: "baccarat", action: "get_balance" };
                const response = await fetch('update_balance.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();

                if (data.success !== false && typeof data.newBalance !== 'undefined') {
                    updateUserBalanceDisplay(data.newBalance);
                } else {
                    console.warn('Failed to fetch balance or no balance data:', data.message);
                    if (userBalanceEl && isInitialLoad) userBalanceEl.textContent = data.message || 'N/A';
                }
                return data;
            } catch (error) {
                console.error('Error fetching balance:', error);
                if (userBalanceEl && isInitialLoad) userBalanceEl.textContent = 'Error';
                return { success: false, message: 'Network error fetching balance.' };
            }
        }

        function updateUserBalanceDisplay(newBalance) {
            currentBalance = parseFloat(newBalance);
            if (userBalanceEl) {
                userBalanceEl.textContent = `₱${currentBalance.toFixed(2)}`;
            }
        }

        // --- UI & Game Flow Functions ---
        function updateTime() {
            if (!currentTimeEl) return;
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const formattedHours = hours % 12 === 0 ? 12 : hours % 12;
            const formattedMinutes = minutes < 10 ? '0' + minutes : minutes;
            currentTimeEl.textContent = `${formattedHours}:${formattedMinutes} ${ampm}`;
        }

        function showMessage(title, htmlMessage) { // Parameter changed to htmlMessage
            messageText.innerHTML = `<strong>${title}</strong><br>${htmlMessage}`;
            messageBox.style.display = 'block';
        }

        function hideMessage() {
            messageBox.style.display = 'none';
        }

        function createCardElement(card, isFaceUp = true) { // Default to face up for simplicity if not specified
            const cardContainer = document.createElement('div');
            cardContainer.classList.add('card-container');
            // cardContainer.classList.add('dealt'); // Add dealt immediately for simplicity unless staggered dealing is needed

            const isRedSuit = card.suit === '♥️' || card.suit === '♦️';
            const suitClass = isRedSuit ? 'red-suit' : 'black-suit';

            if (isFaceUp) {
                cardContainer.innerHTML = `
                    <div class="card-front">
                        <span class="corner-rank top-left ${suitClass}">${card.rank}</span>
                        <span class="suit-icon ${suitClass}">${card.symbol}</span>
                        <span class="corner-rank bottom-right ${suitClass}">${card.rank}</span>
                    </div>`;
            } else {
                cardContainer.innerHTML = `<div class="card-back"></div>`;
            }
            return cardContainer;
        }
        
        function renderCardWithAnimation(card, targetSlotElement, isFaceUpInitially = false) {
            return new Promise(async (resolve) => {
                const cardEl = createCardElement(card, isFaceUpInitially);
                targetSlotElement.appendChild(cardEl);
                
                await new Promise(r => setTimeout(r, 50)); // Short delay for element to be in DOM
                cardEl.classList.add('dealt'); // Trigger opacity transition

                if (!isFaceUpInitially) { // If card needs to be flipped later
                    cardEl.dataset.suit = card.suit; // Store data for revealing
                    cardEl.dataset.rank = card.rank;
                    cardEl.dataset.symbol = card.symbol;
                }
                await new Promise(r => setTimeout(r, 200)); // Animation time
                resolve(cardEl);
            });
        }

        function flipCardElement(cardEl) {
            return new Promise(async (resolve) => {
                // Retrieve stored card data
                const suit = cardEl.dataset.suit;
                const rank = cardEl.dataset.rank;
                const symbol = cardEl.dataset.symbol;
                const isRedSuit = suit === '♥️' || suit === '♦️';
                const suitClass = isRedSuit ? 'red-suit' : 'black-suit';

                // Create the card front content
                const cardFrontHTML = `
                    <div class="card-front">
                        <span class="corner-rank top-left ${suitClass}">${rank}</span>
                        <span class="suit-icon ${suitClass}">${symbol}</span>
                        <span class="corner-rank bottom-right ${suitClass}">${rank}</span>
                    </div>`;
                
                // Simulate flip (replace back with front)
                // For a true CSS flip, you'd use card-inner and rotateY
                cardEl.innerHTML = cardFrontHTML; 
                // If using actual flip animation:
                // cardEl.classList.add('flipped');
                await new Promise(r => setTimeout(r, 600)); // Flip animation duration
                resolve();
            });
        }


        function calculateHandValue(hand) {
            return hand.reduce((sum, card) => sum + card.value, 0) % 10;
        }

        function updateScores() {
            playerScoreEl.textContent = calculateHandValue(playerHand);
            bankerScoreEl.textContent = calculateHandValue(bankerHand);
        }

        function updateBalanceAndBetsUI() {
            totalBetEl.textContent = (bets.player + bets.banker + bets.tie).toFixed(0);
            document.getElementById('player-bet-amount').textContent = bets.player.toFixed(0);
            document.getElementById('banker-bet-amount').textContent = bets.banker.toFixed(0);
            document.getElementById('tie-bet-amount').textContent = bets.tie.toFixed(0);
        }

        function resetGame() {
            playerHand = [];
            bankerHand = [];
            bets = { player: 0, banker: 0, tie: 0 };
            gameInProgress = false;

            playerCardsEl.innerHTML = '';
            bankerCardsEl.innerHTML = '';
            playerScoreEl.textContent = '0';
            bankerScoreEl.textContent = '0';
            gameMessageEl.textContent = 'Place your bets!';

            dealButton.disabled = false;
            clearButton.disabled = false;
            betAreaEls.forEach(area => {
                area.classList.remove('active'); // If 'active' class is used
                const placedChips = area.querySelectorAll('.placed-chip');
                placedChips.forEach(chip => chip.remove());
            });
            updateBalanceAndBetsUI();
        }

        async function determineWinner() {
            const playerTotal = calculateHandValue(playerHand);
            const bankerTotal = calculateHandValue(bankerHand);
            let winner = '';

            if (playerTotal === bankerTotal) winner = 'tie';
            else if (playerTotal > bankerTotal) winner = 'player';
            else winner = 'banker';

            // Client-side message generation
            const playerBetVal = bets.player; // Use local vars for clarity
            const bankerBetVal = bets.banker;
            const tieBetVal = bets.tie;

            const playerReturn = (winner === 'player' && playerBetVal > 0) ? playerBetVal * 2 : 0;
            const bankerReturn = (winner === 'banker' && bankerBetVal > 0) ? bankerBetVal * 1.95 : 0;
            const tieReturn = (winner === 'tie' && tieBetVal > 0) ? tieBetVal * 9 : 0;
            const totalWinningsReturnedClient = playerReturn + bankerReturn + tieReturn;

            let clientMsg = `<p>Player Score: ${playerTotal}, Banker Score: ${bankerTotal}</p>`;
            if (playerBetVal > 0) clientMsg += `<p>Player Bet (${playerBetVal}): ${winner === 'player' ? `Returned ${playerReturn.toFixed(2)}` : 'Lost'}</p>`;
            if (bankerBetVal > 0) clientMsg += `<p>Banker Bet (${bankerBetVal}): ${winner === 'banker' ? `Returned ${bankerReturn.toFixed(2)}` : 'Lost'}</p>`;
            if (tieBetVal > 0) clientMsg += `<p>Tie Bet (${tieBetVal}): ${winner === 'tie' ? `Returned ${tieReturn.toFixed(2)}` : 'Lost'}</p>`;
            if (playerBetVal === 0 && bankerBetVal === 0 && tieBetVal === 0) clientMsg += `<p>No bets were placed.</p>`;
            clientMsg += `<hr class="my-2"><p>Total Returned (Client): ${totalWinningsReturnedClient.toFixed(2)}</p>`;
            
            // Data for server
            const gameDataForServer = {
                game: "baccarat",
                betsPlaced: { player: bets.player, banker: bets.banker, tie: bets.tie },
                gameOutcome: winner
            };

            let serverUpdateMsg = "";
            try {
                const response = await fetch('update_balance.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(gameDataForServer)
                });
                const result = await response.json();
                if (result.success) {
                    updateUserBalanceDisplay(result.newBalance);
                    serverUpdateMsg = `<p class="mt-2 text-green-400">Server: ${result.message || 'Balance updated successfully.'}</p>`;
                } else {
                    if (typeof result.newBalance !== 'undefined') updateUserBalanceDisplay(result.newBalance);
                    serverUpdateMsg = `<p class="mt-2 text-red-400">Server Error: ${result.message || "Could not update balance."}</p>`;
                }
            } catch (error) {
                serverUpdateMsg = `<p class="mt-2 text-red-500">Network Error: Failed to update balance.</p>`;
            }

            showMessage(`${winner.toUpperCase()} Wins!`, clientMsg + serverUpdateMsg);
            gameMessageEl.textContent = `Result: ${winner.toUpperCase()} wins!`;
            dealButton.disabled = true;
            clearButton.disabled = true;
            gameInProgress = true; // Ensure game state is set after all operations
        }

        async function dealCards() {
            if (bets.player === 0 && bets.banker === 0 && bets.tie === 0) {
                showMessage("No Bets Placed", "Please place a bet before dealing.");
                return;
            }
             // Basic check against client-side balance
            const totalBetValue = bets.player + bets.banker + bets.tie;
            if (totalBetValue > currentBalance) {
                showMessage("Insufficient Balance", `Your total bet of ${totalBetValue} exceeds your current balance of ${currentBalance.toFixed(2)}.`);
                return;
            }

            if (gameInProgress) return; // Prevent re-dealing mid-game

            gameInProgress = true;
            dealButton.disabled = true;
            clearButton.disabled = true;
            playerCardsEl.innerHTML = ''; // Clear previous cards
            bankerCardsEl.innerHTML = '';
            playerHand = [];
            bankerHand = [];
            gameMessageEl.textContent = 'Dealing cards...';

            // Deal initial 2 cards to Player and Banker
            const pCard1 = deck.dealCard(); playerHand.push(pCard1);
            const bCard1 = deck.dealCard(); bankerHand.push(bCard1);
            const pCard2 = deck.dealCard(); playerHand.push(pCard2);
            const bCard2 = deck.dealCard(); bankerHand.push(bCard2);

            // Render cards face down initially, then flip
            const pCard1El = await renderCardWithAnimation(pCard1, playerCardsEl, false);
            const bCard1El = await renderCardWithAnimation(bCard1, bankerCardsEl, false);
            await new Promise(r => setTimeout(r, 300)); // Stagger
            const pCard2El = await renderCardWithAnimation(pCard2, playerCardsEl, false);
            const bCard2El = await renderCardWithAnimation(bCard2, bankerCardsEl, false);
            
            await new Promise(r => setTimeout(r, 800)); // Pause before reveal

            // Reveal cards
            await Promise.all([
                flipCardElement(pCard1El), flipCardElement(bCard1El),
                flipCardElement(pCard2El), flipCardElement(bCard2El)
            ]);
            updateScores();

            const playerInitialTotal = calculateHandValue(playerHand);
            const bankerInitialTotal = calculateHandValue(bankerHand);

            // Check for Natural Win (8 or 9 for Player or Banker)
            if (playerInitialTotal >= 8 || bankerInitialTotal >= 8) {
                gameMessageEl.textContent = 'Natural!';
                await new Promise(r => setTimeout(r, 1000));
                determineWinner();
                return;
            }

            // Player's Turn (draw third card if total 0-5)
            let playerDrew = false;
            let playerThirdCardValue = null;
            if (playerInitialTotal <= 5) {
                playerDrew = true;
                gameMessageEl.textContent = 'Player draws...';
                await new Promise(r => setTimeout(r, 1000));
                const pCard3 = deck.dealCard(); playerHand.push(pCard3);
                playerThirdCardValue = pCard3.value; // Get Baccarat value
                const pCard3El = await renderCardWithAnimation(pCard3, playerCardsEl, false);
                await new Promise(r => setTimeout(r, 800));
                await flipCardElement(pCard3El);
                updateScores();
            }

            // Banker's Turn (based on Player's hand and Banker's current total)
            const bankerCurrentTotal = calculateHandValue(bankerHand); // Re-calc as player might have drawn
            let bankerShouldDraw = false;

            if (!playerDrew) { // Player stood pat (total 6 or 7)
                if (bankerCurrentTotal <= 5) bankerShouldDraw = true;
            } else { // Player drew a third card
                if (bankerCurrentTotal <= 2) bankerShouldDraw = true;
                else if (bankerCurrentTotal === 3 && playerThirdCardValue !== 8) bankerShouldDraw = true;
                else if (bankerCurrentTotal === 4 && [2,3,4,5,6,7].includes(playerThirdCardValue)) bankerShouldDraw = true;
                else if (bankerCurrentTotal === 5 && [4,5,6,7].includes(playerThirdCardValue)) bankerShouldDraw = true;
                else if (bankerCurrentTotal === 6 && [6,7].includes(playerThirdCardValue)) bankerShouldDraw = true;
            }

            if (bankerShouldDraw) {
                gameMessageEl.textContent = 'Banker draws...';
                await new Promise(r => setTimeout(r, 1000));
                const bCard3 = deck.dealCard(); bankerHand.push(bCard3);
                const bCard3El = await renderCardWithAnimation(bCard3, bankerCardsEl, false);
                await new Promise(r => setTimeout(r, 800));
                await flipCardElement(bCard3El);
                updateScores();
            }
            
            gameMessageEl.textContent = 'Determining winner...';
            await new Promise(r => setTimeout(r, 1500));
            determineWinner();
        }


        // --- Event Listeners ---
        chipEls.forEach(chip => {
            chip.addEventListener('click', () => {
                if (gameInProgress) return;
                chipEls.forEach(c => c.classList.remove('selected'));
                chip.classList.add('selected');
                selectedChipValue = parseInt(chip.dataset.value);
            });
        });
        if (chipEls.length > 0) chipEls[0].classList.add('selected'); // Select first chip by default


        betAreaEls.forEach(area => {
            area.addEventListener('click', () => {
                if (gameInProgress) {
                    showMessage("Game in Progress", "Bets are locked. Start a new game to place new bets.");
                    return;
                }
                if (selectedChipValue === 0) {
                     showMessage("No Chip Selected", "Please select a chip value first.");
                    return;
                }

                const betType = area.dataset.betType;
                bets[betType] += selectedChipValue;
                updateBalanceAndBetsUI();

                // Add visual chip to bet area
                const placedChipEl = document.createElement('div');
                placedChipEl.classList.add('placed-chip');
                placedChipEl.textContent = selectedChipValue;
                const selectedChipStyle = Array.from(chipEls).find(c => c.classList.contains('selected'));
                if (selectedChipStyle) {
                    placedChipEl.style.backgroundColor = getComputedStyle(selectedChipStyle).backgroundColor;
                }
                area.appendChild(placedChipEl);
            });
        });

        dealButton.addEventListener('click', dealCards);

        clearButton.addEventListener('click', () => {
            if (gameInProgress) {
                showMessage("Game in Progress", "Cannot clear bets now. Start a new game.");
                return;
            }
            resetGame(); // This also updates UI for bets
        });

        newGameButton.addEventListener('click', () => {
            resetGame();
            // deck.reset(); // Deck is reset by its own logic when low on cards.
                         // If explicit reset per game desired, uncomment and test.
            // fetchAndUpdateBalance(); // Optionally refresh balance display from server
        });

        messageOkButton.addEventListener('click', hideMessage);

        // --- Initializations ---
        (async () => {
            await initFirebase(); // Initialize Firebase and handle auth
            // Initial UI updates that depend on auth or initial state
            updateTime();
            setInterval(updateTime, 1000);
            resetGame(); // Set up the initial game state on the client

            // Select first chip by default after everything is ready
            if (chipEls.length > 0 && !document.querySelector('.chip.selected')) {
                 chipEls[0].classList.add('selected');
                 selectedChipValue = parseInt(chipEls[0].dataset.value);
            }
        })();

    </script>
</body>
</html>